<range-control>
  <svg viewBox="0 0 {this.svgWidth()} {this.svgHeight()}">
    <g class="bins" fill="#aaaaaa">
      <rect
        each={(bin, index) in this.props.bins}
        x="calc({this.binIndexToPercent(index)}% - {(this.props.binWidth || 1) / 2}px)"
        height="{this.binToHeight(bin)}%"
        y="{90 - this.binToHeight(bin) - 10}%"
        width={this.props.binWidth || 1}
        fill={this.binColor(index)}
      />
    </g>
    <g class="background" fill="#aaaaaa">
      <!-- <rect width="80%" height="1px" x="10%" y="calc(90% - 0px)" /> -->
      <rect width="100%" height="1" x="0%" y="90%" />
      <!-- <rect width="1" height="10%" x="10%" y="calc(90% - 5%)" /> -->
      <!-- <rect width="1" height="10%" x="90%" y="calc(90% - 5%)" /> -->
    </g>
    <g class="controls" fill="#5EC1ABaa">
      <circle class="from" cx="{this.valueToPercent(this.state.from)}%" cy="90%" r="0.5em" />
      <circle class="to" cx="{this.valueToPercent(this.state.to)}%" cy="90%" r="0.5em" />
    </g>

    <!-- <g x="10%">
      <rect width="80%" height="10" x="10%" y="50%" />
    </g> -->
  </svg>

  <div class="literals">
    <div>{this.props.min}</div>
    <div>{this.state.from} â€“ {this.state.to}</div>
    <div>{this.props.max}</div>
  </div>

  <script>
    import *as d3Selection from 'd3-selection'
    import * as d3Scale from 'd3-scale'
    import * as d3Drag from 'd3-drag'

    const d3 = Object.assign({}, d3Selection, d3Scale, d3Drag)

    export default class {
      onBeforeMount(props, state) {
        this.state = {
          from: props.from,
          to: props.to
        }
      }

      binColor(index) {
        const active = (
          this.binIndexToPercent(index) >= this.valueToPercent(this.state.from) &&
          this.binIndexToPercent(index) <= this.valueToPercent(this.state.to)
        )

        return active ? '#232323' : ''
      }

      valueToPercent(value) {
        const m = d3.scaleLinear().
          domain([this.props.min, this.props.max]).
          range([0, 100])

        return m(value)
      }

      binToHeight(value) {
        const m = d3.scaleLinear().
          domain([0, this.maxBin()]).
          range([0, 80])

        return m(value)
      }

      binIndexToPercent(index) {
        const m = d3.scaleLinear().
          domain([0, this.props.bins.length - 1]).
          range([0, 100])

        return m(index)
      }

      maxBin() {
        const values = this.props.bins
        return Math.max(...values)
      }

      svgWidth() {
        return this.root.querySelector('svg').getBoundingClientRect().width
      }

      svgHeight() {
        return this.root.querySelector('svg').getBoundingClientRect().height
      }

      clamp(value) {
        let r = Math.max(value, this.props.min)
        return Math.min(r, this.props.max)
      }

      mapRange(value, from = [0.0, 1.0], to = [0.0, 1.0]) {
        return (value - from[0]) / from[1] * (to[1] - to[0]) + to[0]
      }

      onMounted(props, state) {
        const component = this

        const m = d3.scaleLinear().
          domain([0, this.svgWidth()]).
          range([props.min, props.max]).
          clamp(true)

        const drag = function(event) {
          const value = Math.round(m(event.x))

          const side = (this.classList.contains('from') ? 'from' : 'to')
          // newValue = component.clamp(newValue)
          component.update({[side]: value})

          if (side == 'from' && value > component.state.to) {
            component.update({to: value})
          }

          if (side == 'to' && value < component.state.from) {
            component.update({from: value})
          }
        }

        d3.select(this.root).
          selectAll(".controls circle").
          call(d3.drag().on('drag', drag))        
      }
    }
  </script>
</range-control>
